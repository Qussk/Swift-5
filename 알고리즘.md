# 알고리즘


## 어원

**Algorithm [ӕlgərɪðəm]**

- 앨거리덤, 알고리듬 / 알고리즘(X)
- 어떤 문제를 해결하기 위해 정의된 절차와 방법, 명령어의 집합
- 9세기 페르시아 수학자, 무하마드 알콰리즈미(Muhammad al-Kwarizmi) 의 이름에서 유래
'콰라즘에서 온 사람이 가르쳐 준 수 (알 콰라즘)’ -> 알고리즘



### Flowchart

![](/image/argo1.png)

![](image/argo2.png)



## Alforithm 조건

알고리즘은 다음의 조건을 만족해야 함

• 입력 : 외부에서 제공되는 자료가 0개 이상 존재한다.
• 출력 : 적어도 1개 이상의 결과물을 출력해야 한다.
• 명확성 : 수행 과정은 명확해야 하고 모호하지 않은 명령어로 구성되어야 한다.
• 효율성 : 모든 과정은 명백하게 실행 가능(검증 가능)한 것이어야 한다.
• 유한성(종결성) : 알고리즘의 명령어들은 계산을 수행한 후 반드시 종료해야 한다.


## Examples

- 택배를 가장 빠르게 배달할 수 있는 루트
- 로봇 청소기의 움직임
- 자동 주식 거래 시스템
- 최적의 검색 결과
- 얼굴 / 지문 인식
- Siri


## Google Search Alforithm 

세르게이 브린, 래리 페이지 논문
- The Anatomy of a Large-Scale Hypertextual Web Search Engine 
[[링크]](http://infolab.stanford.edu/~backrub/google.html)
- PageRank : 특정 페이지를 인용하는 다른 페이지가 얼마나 많이 있는지를 통해 랭킹 반영

![](image/argo3.png)


## Why Algorithm?

[ 알고리즘을 공부해야 하는 이유 ]
- 문제 해결력 상승
- 관련된 케이스를 알고 있으면 다음에 유사한 문제를 쉽게 해결 가능
- 평상시 화면 구현 집중. 시간 복잡도 / 공간 복잡도 / 메모리 관심 X
알고리즘 학습을 통해 해당 부분에 대한 관심 + 고민 + 접근법 향상


### Common Astmptotic Notations 

![](image/argo4.png)
위로 갈수록 좋음 

![](image/wkfy3.png)

O (n!)-요인 복잡성
예 : 정렬 알고리즘에 요인이 복잡하다고 가정하십시오. 배열에 10 개의 요소가있는 경우 배열을 정렬하려면 3628800 단계 (10! 또는 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1)가 걸립니다.

- O (2 n )-지수 복잡성
예 : 정렬 알고리즘이 지수 적으로 복잡하다고 가정하면, 배열에 10 개의 요소가있는 경우 배열을 정렬하는 데 1024 단계 (2 ^ 10)가 걸림.

- O (n 2 )-이차 복잡성
예 : 정렬 알고리즘에 2 차 복잡성이 있다고 가정하면,. 배열에 10 개의 요소가 있으면 배열을 정렬하는 데 100 단계 (10 ^ 2)가 걸림.

- O (n log 2 n)-선형 복잡성
예 : 정렬 알고리즘에 선형 복잡성이 있다고 가정하면, 배열에 10 개의 요소가있는 경우 배열 을 정렬하는 데 ~ 33-34 단계 (10 * (log 2 10)) 가 걸림 .

- O (n)-선형 복잡도
예 : 정렬 알고리즘에 선형 복잡성이 있다고 가정하면, 배열에 10 개의 요소가 있으면 배열을 정렬하는 데 10 단계가 필요. 선형 복잡도는 요소 수만큼 많은 단계를 수행.

- O (log 2 n)-로그 복잡성
예 : 정렬 알고리즘에 로그 복잡성이 있다고 가정하면, 배열에 10 개의 요소가있는 경우 배열 을 정렬하는 데 ~ 3-4 단계 (log 2 10) 가 걸림 .


# Sortiong Algorithm (정렬 알고리즘)

정렬 알고리즘 - 알고리즘을 소개할 때 가장 대표적으로 소개되는 케이스
worst, average, best case 등을 이해하기 쉽고 시각적으로 표현하기 좋음
다양한 곳에서 자주 쓰이기 때문에 이미 다양한 알고리즘이 나와있고 현재도 계속 연구중

- [15 Sorting Algorithms](https://www.youtube.com/watch?v=kPRA0W1kECg)
- [Visualization and Comparison of Sorting Algorithms](https://www.youtube.com/watch?v=ZZuD6iUe3Pc)
- [Bubble-sort with Hungarian ("Csángó") folk dance](https://www.youtube.com/watch?time_continue=108&v=lyZQPjUT5B4)
- [Merge Sort vs Quick Sort](https://www.youtube.com/watch?v=es2T6KY45cA)
- [Sorting](http://sorting.at/)
- [swift-algorithm-club](https://github.com/raywenderlich/swift-algorithm-club)


# Bubble Sort(버블정렬)

- 인접한 두 원소의 크기를 비교하여 큰 값을 배열의 오른쪽으로 정렬해 나가는 방식
- 이미 대 부분 정렬되어 있는 자료에서는 좋은 성능을 보이지만 그 외에는 매우 비효율적인 알고리즘
- 단, 직관적이어서 쉽고 빠르게 구현 가능하여 많이 알려져 있음
시간복잡도 - O(n2(제곱임)) 
- 서로의 두 수를 비교하여 오른쪽으로 나아감
- 최상의 케이스 복잡성 : О (n) 최악의 케이스 복잡성 : О (n ^ 2)

![](/image/argo5.png)


![](/image/argo6.png)

![](/image/argo7.png)
![](/image/argo8.png)
![](/image/argo9.png)


이런 식으로 
(정렬이 될 때까지 반복. )


### 실습 
1)
```swift



```
2) 기본형
```swift
func bubbleSort(arr: [Int]) -> [Int]{
  var array = arr
  for _ in 0..<array.count - 1
  {
    for j in 0..<array.count - 1
    {
      if (array[j] > array[j+1]) {
      let temp = array[j]
      array[j] = array[j+1]
      array[j+1] = temp
    }
  }
}
return array
}
let unsortedArray = [4,3,6,8,2,9]
print(bubbleSort(arr: unsortedArray))
```


실습하긴 했는데, [swift-algorithm-club](https://github.com/raywenderlich/swift-algorithm-club)에서는 **버블정렬**과 **느린정렬**은 잘못된 정렬 알고리즘으로 권장하지는 않고 있다. 오로지 학습용으로만! ! 🤔



# Selection Sort(삽입정렬)

데이터를 반복 순회하며 최소값을 찾아 정렬되지 않는 숫자 중 가장 좌측의 숫자와 위치 교환하는 방식
- 최소값 선택 정렬 (Min-Selection Sort) : 가장 작은 값을 기준으로 정렬 (오름차순)
- 최대값 선택 정렬 (Max-Selection Sort) : 가장 큰 값을 기준으로 정렬 (내림차순)
시간복잡도 - O(n2)
- 최상의 케이스 복잡성 : О (n) 최악의 케이스 복잡성 : О (n ^ 2)

```
[3,4,5,1,0,8,1]
[3]|[4,5,1,0,8,1]
[3,4]|[5,1,0,8,1]
[3,4,5]|[1,0,8,1]
[1,3,4,5]|[0,8,1]
[0,1,3,4,5]|[8,1]
[0,1,3,4,5,8]|[1]
[0,1,3,4,5,8,1]
```
오른쪽에서 왼쪽으로 순차적으로 이동되는 모습. 










